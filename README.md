# SELab_HW1
## گزارش آزمایش

برای انجام آزمایش به نکات زیر توجه کنید:
* [x] <br/>
انتظار می‌رود که فرآیند ایجاد این نرم‌افزار، به صورت همزمان توسط همه‌ی اعضای تیم ایجاد، در یک مخزن کد (repository) در Github دنبال شود.
* [x] <br/>
در پروژه‌ی خود از فایل .gitignore استفاده کنید.
* [x] <br/>
نیاز است تا حداقل ۲۰ commit معنا‌دار در فرآیند پیاده‌سازی نرم‌افزار وجود داشته باشد. منظور از معناداری commit ها، این است که اتفاق مشخصی در فرآیند پیاده‌سازی رخ داده باشد.
* [x] <br/>
لازم است برای مدیریت بهتر فرآیند پیاده‌سازی نرم‌افزار، از حداقل سه شاخه‌ی معنا‌دار استفاده کنید.

	استفاده از شاخه‌های زیر:

feature/feature-name: برای اضافه کردن فیچر جدید

bugfix/bug-name: برای درست کردن باگ

hotfix/critical-bug-name: برای درست کردن ایشویی که باید سریع برطرف شود

release-name: در انتهای هر ریلیز از شاخه‌ی main یک شاخه‌ی جدید با نام ریلیزی که تمام شده ساخته می‌شود تا بتوان نسخه‌ی ورژن‌های مختلف را از هم تفکیک کرد و در صورت نیاز باگ‌هایی که روی هر نسخه می‌آید را روی شاخه‌ی خودش برطرف کرد. شاخه‌ی main نشان‌دهنده‌ی ریلیز فعلی است.

* [x] <br/>
حداقل دو conflict را در فرآیند پیاده‌سازی برطرف کنید. این conflict ها می‌تواند در یک شاخه یا هنگام ادغام دو شاخه رخ دهد.
* [x] <br/>
با اعمال محدودیت در مخزن خود در Github، شاخه‌ی main پروژه را محافظت کنید؛ به صورتی که تنها از طریق pull request امکان ادغام شاخه‌ای دیگر با شاخه‌ی main را داشته باشید.

مراحل پیاده‌سازی:

۱. رفتن به بخش تنظیمات ریپو

۲. انتخاب گزینه‌ی Branches از سایدبار چپ

۳. انتخاب گزینه‌ی Add classic branch protection rule

۴. نوشتن نام شاخه‌ی main در branch name pattern

۵. انتخاب گزینه‌ی require a pull request before merging

۶. زدن دکمه‌ی create برای اعمال محدودیت حفاظت از شاخه‌ی main


* [x] <br/>
 ‌ضروری است شاخه‌ها را به درستی با شاخه‌ی main و یا دیگر شاخه‌های مرتبط ادغام (merge) کنید. این کار را از طریق pull request انجام دهید.
* [x] <br/>
برای استقرار مستمر با کمک Github Actions، می‌توانید از workflow های آماده استفاده کنید.

۱. رفتن به بخش تنظیمات ریپو

۲. انتخاب گزینه‌ی Pages از سایدبار چپ

۳. انتخاب Github Actions به عنوان source

* [x] <br/>
 گزارشی از جزئیات پیاده‌سازی مراحل فوق را با فرمت markdown در فایل README پروژه بنویسید.

## پرسش‌ها
 ۱. پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟</br>
جواب: پوشه‌ی .git یک پوشه مخفی در ریشه‌ی مخزن گیت است که تمام اطلاعات مربوط به ردیابی تغییرات در کد را ذخیره می‌کند. این پوشه شامل فایل‌ها و پوشه‌های زیر است: </br>
<p align="center">
  <img src="https://github.com/Fonij80/SELab_HW1/assets/93675264/7254c46a-c8ef-4ddb-b16c-d2561f9cfb84" width="30%" />
</p>
<p dir="rtl" align="right">
فایل HEAD: شاخصی برای شاخه فعلی. </br>
فولدر refs: ذخیره ارجاعات به کامیت‌ها و شاخه‌ها. </br>
فولدر objects: نگهداری کد به عنوان یک سری snapshot‌ها. </br>
فایل config: ذخیره اطلاعات پیکربندی گیت. 
فولدر hooks: اجرای اسکریپت‌ها در نقاط خاصی از جریان کاری گیت.
</p>

* [Reference1](https://dev.to/rajaniraiyn/understanding-the-contents-of-the-git-folder-ef)

۲. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟</br>
جواب: منظور از atomic بودن در atomic commit و atomic pull request این است که هر تغییر به صورت یک واحد مستقل و کامل عمل کند. هر atomic commit یا atomic pull request باید تنها شامل یک تغییر منطقی و مستقل باشد که به طور کل قابل فهم و بررسی است.
در یک atomic commit، تغییرات به یک هدف خاص و مشخص اختصاص دارند و نباید شامل تغییرات مختلف و نامرتبط باشند. به طور مشابه، یک atomic pull request نیز باید تنها شامل یک تغییر مشخص و مستقل باشد. این pull requestها نباید مجموعه‌ای از تغییرات نامرتبط را در بر گیرند و باید به تنهایی قابل بررسی و ارزیابی باشند.


۳. تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید.</br>
جواب:         دستور fetch تنها برنچ های remote-tracking را آپدیت می‌کند و ادغامی (merge) انجام نمی‌دهد.</br>
        در مقابل pull ترکیبی از fetch و merge است و ابتدا تغییرات را دریافت می‌کند و سپس آنها را با برنچ فعلی ما ادغام می‌کند.</br>
        دستور rebase دنباله ای از commit ها در یک برنچ را روی یک برنچ دیگر اعمال می‌کند.</br>
        که در مقابل cherry-pick برای اعمال برخی commit های خاص (بدون ادغام کل برنچ) استفاده می‌شود.</br/><br>
 
۴. تفاوت دستورهای reset و revert و restore و switch و checkout را بیان کنید.</br>
جواب:         دستور reset برای تغییر برنچ و حذف تغییرات به کار می‌رود(تاریخچه را تغییر میدهد).</br>
        در مقابل دستور revert برای ایجاد یک commit جدید برای معکوس کردن تغییرات به کار می‌رود(تاریخچه را تغییر میدهد) و دستور restore برای بازگرداندن فایل ها به وضعیت قبلی است(تغییرات را حذف می‌کند).</br>
        دستور switch تنها برای تغییر برنچ ‌ها استفاده می‌شود، در حالی که دستور checkout می‌تواند هم برای تغییر برنچ ها و هم برای بازگرداندن فایل‌ها به یک commit مشخص شده استفاده شود.</br/><br>

۵. منظور از stage یا همان index چیست؟ دستور stash چه کاری را انجام می‌دهد؟</br>
جواب: Stage یا index همان وضعیت working directory قبل از کامیت است، در واقع همان تغییراتی که اضافه شده‌اند و قرار است که کامیت شوند. با دستور git add فایل‌هایی که تغییر کرده‌اند به index اضافه می‌شوند و تغییراتی که بعد از این دستور اعمال می‌شوند در ‌index دیده نمی‌شوند تا وقتی که دوباره دستور git add زده شود. با زدن دستور git commit تغییراتی که در index وجود دارند کامیت می‌شوند. </br>
دستور stash تغییراتی که در پروژه داده‌ایم و فعلا به آن‌ها نیازی نداریم ولی بعدا ممکن است لازم‌مان شود (تغییرات کامیت‌نشده)، را نگه می‌دارد. باز زدن دستور ‌git stash وضعیت فعلی working directory و تغییرات ذخیره می‌شوند و تغییرات به سر (head) آخرین کامیت برمی‌گردند (revert).

* [Reference1](https://stackoverflow.com/questions/12138207/is-the-git-staging-area-just-an-index)
* [Reference2](https://stackoverflow.com/questions/20537223/what-is-the-intended-use-case-for-git-stash)

۶. مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟</br>
جواب: اسنپ‌شات همان استیت کل فولدرهای پروژه در یک زمان مشخص است و هر زمانی که کامیتی را انجام می‌دهیم گیت از تمام فایل‌های working directory اسنپ‌شات می‌گیرد و آن را در ریپوی پروژه ذخیره می‌کند. (اطلاعات اسنپ‌شات در فولدر .git/objects در ریپو ذخیره می‌شود و هر کامیتی به عنوان یک آبجکت در این فولدر ذخیره می‌شود) در working directory تغییرات روی فایل‌ها اعمال می‌شود، با دستور git add تغییرات را stage می‌کنیم و در نهایت با دستور git commit گیت اسنپ‌شاتی از فایل‌هایی که در ‌staging area موجود هستند، می‌گیرد و آن را به طور دائم در ریپو نگه می‌دارد. در واقع هر کامیت نشان‌دهنده‌ی اسنپ‌شات کاملی از پروژه در زمان مشخصی است و شامل تمام فایل‌ها و متادیتاهایی مانند نام فرد کامیت‌کننده، زمان و پیام کامیت است. </br>
commit = snapshot + metadata

* [Reference1](https://stackoverflow.com/questions/4964099/what-is-a-git-snapshot)

۷. تفاوت‌های local repository و remote repository چیست؟</br>
جواب: Local Repository یک نسخه از تاریخچه کامل پروژه و کدهای آن است که روی دستگاه local توسعه‌دهنده قرار دارد. وقتی یک توسعه‌دهنده local repository را ایجاد می‌کند، گیت زیرساخت‌های لازم برای ردیابی تغییرات، شاخه‌ها و کامیت‌ها را درون پروژه تنظیم می‌کند. یکی از مزایای local repository این است که به توسعه‌دهندگان اجازه می‌دهد تا بدون نیاز به اینترنت، تغییرات خود را ثبت کنند. این ویژگی در شرایطی که دسترسی به اینترنت محدود یا نامطمئن است، بسیار مفید است. همچنین، از آنجا که تمام کد و تاریخچه به صورت local ذخیره شده، عملیات‌های گیت مانند ثبت تغییرات، تغییر شاخه‌ها و مشاهده تاریخچه کامیت‌ها بسیار سریع انجام می‌شود. در یک local repository، توسعه‌دهندگان آزادی این را دارند که ویژگی‌های جدید پروژه را آزمایش کنند، کد را اصلاح کنند و رویکردهای مختلف را بدون تاثیر بر کد اصلی آزمایش کنند. شاخه‌های local می‌توانند یک محیط جدا ایجاد کنند و تغییرات تنها زمانی که آماده اشتراک‌گذاری با دیگران هستند، مرج شوند.
در مقابل، Remote Repository روی یک سرور remote یا پلتفرم میزبانی کد مانند GitHub، GitLab یا Bitbucket میزبانی می‌شود. Remote repository به عنوان یک هسته مرکزی عمل می‌کند که توسعه‌دهندگان می‌توانند از آن برای همکاری و اشتراک‌گذاری کارهای خود با دیگران استفاده کنند. با یک مخزن راه‌دور، توسعه‌دهندگان می‌توانند کامیت‌های local خود را به سرور remote ارسال کنند و آخرین تغییرات ایجاد شده توسط دیگر اعضای تیم را دریافت کنند. یکی از مزایای remote repository آسان‌تر کردن همکاری است. چندین توسعه‌دهنده می‌توانند همان remote repository را کلون کنند و هر کدام نسخه local خود را داشته باشند و به طور همزمان روی پروژه کار کنند. Remote repository به عنوان نقطه مرکزی همگام‌سازی عمل می‌کند و به اعضای تیم این امکان را می‌دهد تا تغییرات خود را مرج کنند و در صورت نیاز conflict‌ها را حل کنند.همچنین بک‌آپ گرفتن از کد را فراهم می‌کند. با میزبانی پروژه روی پلتفرم‌هایی مانند GitHub، توسعه‌دهندگان می‌توانند کارهای خود را به نمایش بگذارند و با دیگران از طریق pull request همکاری کنند. علاوه بر این، یک remote repository ایمنی و دسترسی پروژه را تضمین می‌کند. در صورت خرابی یا از دست رفتن سیستم local، توسعه‌دهندگان می‌توانند به راحتی با کلون کردن remote repository روی سیستم جدید، پروژه خود را بازیابی کنند.
در نهایت، کار با گیت شامل مدیریت هر دو مخزن local و remote است. Local repository دسترسی آفلاین، سرعت و انعطاف‌پذیری برای امتحان و آزمایش را فراهم می‌کند، در حالی که remote repository امکان همکاری، گرفتن بک‌آپ و مشاهده پروژه‌ها را فراهم می‌کند. 
* [Reference1](https://levelup.gitconnected.com/git-working-with-local-repository-vs-working-with-remote-repository-b2ec00df9a2e)


